## **문자열 연산 함수**

### 문자열을 대입하는 strcpy 함수

strcpy 함수는 문자열 연산 함수라고 하며 사용하려면 string.h 헤더 파일을 인클루드해야 한다. strcpy 함수는 string copy, 즉 문자열 복사의 약어이다.

strcpy(str1, str2)

str1: 복사 받을 곳

str2: 복사할 내용

strcpy 함수는 복사 받을 곳의 배열명을 첫 번째 인수로 주고 복사할 문자열을 두 번째 인수로 준다. 문자열을 복사하는 방식은 문자열의 첫 번째 문자부터 널 문자가 나올 때까지 문자를 하나씩 배열에 옮겨 저장한다. 따라서 복사할 문자열의 시작 위치를 알 수 있다면 어떤 것이든 두 번째 인수로 사용할 수 있다.

---

### 원하는 개수의 문자만을 복사하는 strncpy 함수

strncpy 함수는 문자열을 복사할 때 문자의 수를 지정할 수 있다.

strncpy(str, “apple-pie”, 5);

str: 복사 받을 배열명

“apple-pie”: 복사할 문자열

5: 복사할 문자
```C
#include <stdio.h>
#include <string.h>

int main()
{
    char str[20] = "mango tree";
    
    strncpy(str, "apple-pie", 5);
  
    printf("%s\n", str);
  
    return 0;
}
```
strncpy 함수는 복사할 문자열에서 지정한 개수만큼 문자를 복사하고 널 문자는 저장하지 않는다. 따라서 str 배열에서 mango만 apple로 바뀌므로 결국 str 배열에 저장된 문자열은 “apple tree”가 된다.

만약 str 배열이 문자열 “apple”로만 쓰이도록 하려면 apple을 복사한 후에 널 문자를 별도로 저장해야 한다.

---

### 문자열을 붙이는 strcat, strncat 함수

배열에 있는 문자열 뒤에 이어 붙일 때는 strcat 또는 strncat 함수를 사용한다. strcat 함수는 문자열을 이어 붙이며, strncat 함수는 지정한 문자의 개수만큼 붙인다.

- strcat 함수는 메모리를 침범할 수 있다.

strcat 함수는 문자열을 덧붙이는 것이므로 붙여넣기가 되는 배열의 크기가 충분히 커야 한다.

- strcat 함수를 사용할 때는 배열을 초기화해야 한다.

strcat 함수로 붙여넣기 전에 먼저 널 문자의 위치를 찾으므로 반드시 초기화를 해야한다.

- strncat 함수는 strncpy 함수와 달리 붙여넣은 후에는 널 문자를 저장하여 문자열을 완성한다.

---

### 문자열 길이를 계산하는 strlen 함수

배열에 저장된 문자열의 실제 길이를 알고 싶을 때 strlen 함수를 사용한다.

strlen(str)

str: 크기를 확인할 배열명

strlen 함수는 배열에 저장된 문자열에서 널 문자가 나올 때까지 문자 수를 세어 반환한다. 따라서 배열의 크기와는 상관없이 실제 저장된 문자열의 길이를 확인할 수 있다. 문자열의 길이를 반환하므로 반환값을 바로 비교하거나 수식의 일부로 사용할 수 있다.

---

### 문자열을 비교하는 strcmp, strncmp 함수

strcmp 함수는 두 문자열의 사전 순서를 판단하여 그 결과를 반환한다. 사전 순서는 사전에 단어가 수록되는 알파벳 순서를 말하며, 함수의 사용법과 반환값은 다음과 같다.
```
strcmp(str1, str2)         // str1이 str2보다 사전에 나중에 나오면 1 반환

                           // str1이 str2보다 사전에 먼저 나오면 -1 반환

                           // str1과 str2가 같은 문자열이면 0 반환
```
strncmp 함수는 strcmp 함수와 거의 같지만 비교할 문자 수를 세 번째 인수로 지정할 수 있다.

---

## 변수의 영역과 데이터 공유

---

## 변수 사용 영역

### 지역 변수

지역 변수는 범위가 함수 내, 즉 일정 지역에서만 사용하는 변수이다. 본래 auto 예약어와 함께 함수 안에 지역 변수를 선언한다. auto 예약어는 생략할 수 있으며 이 경우 함수 안에 선언된 변수는 자동으로 지역 변수가 된다.

- 지역 변수는 사용 범위가 블록 내부로 제한되므로 다른 함수에서는 사용할 수 없다.

따라서 다른 함수에 같은 이름의 변수를 선언해도 이름이 서로 충돌하지 않는다.

- 지역 변수는 이름이 같아도 선언된 함수가 다르면 각각 독립된 저장 공간을 가진다.

즉, 두 함수에 선언된 동일한 이름의 변수는 이름만 같을 뿐 메모리에 별도의 저장 공간을 가진다.

---

### 지역 변수 사용의 장점

- 메모리를 효율적으로 사용한다

지역 변수는 함수 안에서만 사용하므로 함수가 반환되면 그 저장 공간을 계속 유지할 필요가 없다. 따라서 운영체제는 지역 변수가 선언된 함수가 반환되면 할당된 저장 공간을 자동으로 회수하여 재활용한다.

- 디버깅에 유리하다

지역 변수는 값에 문제가 있을 때 수정하기 쉽다. 선언된 함수에서만 그 원인을 찾으면 된다.

---

### 블록 안에서 사용하는 지역 변수

지역 변수는 보통 함수 안에서 선언한 후 함수 끝까지 사용하지만 선언 위치에 따라 사용 범위가 달라질 수 있다.

- 특정 블록 안에 변수를 선언하면 사용 범위가 블록 내부로 제한된다.

메모리에 할당된 저장 공간도 블록이 끝나면 자동으로 회수되어 더 이상 존재하지 않는다.

- 사용 가능한 변수가 둘 이상이면 가장 가까운 블록에 선언된 변수를 사용한다.
```C
#include <stdio.h>

int main()
{
    int a =10, b = 20;
    
    printf("교환 전 a와 b의 값 : %d, %d\n", a, b);
    {
        int temp;
        temp = a;
        a=b;
        b=temp;
    }
    printf("교환 후 a와 b의 값 : %d, %d\n",a,b);
  
    return 0;
}
```
{}안에 새로운 변수 a, b를 선언하면 블록 안에서는 맨위에 선언된 변수 a와 b대신 가까운 블록에 선언된 블록안의 변수 a와 b를 사용한다. 안쪽 블록에서 선언된 변수 a와 b는 메모리에 독립된 저장 공간을 가지므로 안쪽 블록에서 a나 b 값을 바꾸어도 맨위의 a와 b 값에는 변함이 없다. 그리고 안쪽 블록에서 선언된 변수들은 블록이 끝나면 저장 공간이 회수되어 더 이상 사용할 수 없으므로, 마지막 출력은 맨위의 변수 a, b의 값이 출력된다.

---

### 전역 변수

함수 밖에 변수를 선언하면 전역 변수가 된다. 전역 변수는 특정 함수의 블록에 포함되지 않으므로 사용 범위가 함수나 블록으로 제한되지 않는다.

---

### 전역 변수의 문제점

전역 변수는 모든 함수에서 자유롭게 접근할 수 있으므로 같은 변수를 여러 함수에서 쉽게 공유할 수 있다.

- 전역 변수의 이름을 바꾸면 그 변수를 사용하는 모든 함수를 찾아 수정해야 한다.
- 전역 변수의 값이 잘못된 경우 접근 가능한 모든 함수를 의심해야 한다.
- 코드 블록 내에 같은 이름의 지역 변수를 선언하면 그 영역에서는 전역 변수를 사용할 수 없다.

---

### 정적 지역 변수

지역 변수를 선언할 때 static 예약어를 사용하면 정적 지역 변수가 된다. 정적 지역 변수는 코드 블록 안에 선언하므로 일반 지역 변수와 같이 사용 범위가 블록 내부로 제한된다. 반면에 저장 공간이 메모리에 존재하는 기간이 다르다.

정적 지역 변수는 선언된 함수가 반환되더라도 그 저장 공간을 계속 유지한다. 따라서 하나의 함수가 여러 번 호출되는 경우 같은 변수를 공유하는 것이 가능하다.

---

### 레지스터 변수

레지스터 변수는 블록 혹은 함수 내에 변수를 선언할 때 register 예약어를 사용한다. 레지스터 변수의 가장 큰 특징은 저장 공간이 할당되는 위치에 있다. 바로 이름과 같이 레지스터 변수는 CPU 안에 있는 저장 공간인 레지스터를 사용한다.

레지스터는 CPU 안에 있어 데이터 처리 속도가 가장 빠른 저장 공간이다. 따라서 반복문에 쓰는 변수와 같이 사용 횟수가 많은 경우 레지스터에 할당하면 실행 시간을 줄일 수 있다.

---

### 레지스터 변수 사용 시 주의점

- 전역 변수는 레지스터 변수로 선언할 수 없다.

레지스터 변수는 CPU의 자원을 잠깐 빌리는 것이므로 프로그램을 실행하는 동안 계속 저장 공간을 확보해야 하는 전역 변수는 레지스터에 할당할 수 없다.

- 레지스터 변수는 주소를 구할 수 없다.

레지스터 변수는 저장 공간이 메모리에 있는 것이 아니므로 주소 연산자를 써서 주소를 구할 수 없다.

- 레지스터의 사용 여부는 컴파일러가 결정한다.

레지스터 변수를 선언했다고 모두 레지스터에 변수가 생성되는 것은 아니다. 레지스터는 CPU의 연산장치가 사용하는 비싸고 중요한 저장 공간이므로 당장 연산할 필요가 없는 데이터를 레지스터에 보관하면 레지스터의 활용성이 떨어진다. 따라서 컴파일러는 사용자가 레지스터 변수를 선언하더라도 레지스터와 메모리 중에 어디에 할당하는 것이 더 이득인지 판단하여 적당한 저장 공간을 선택한다.
  
