## 함수의 데이터 공유 방법

### 값을 복사해서 전달하는 방법

함수를 호출할 때 필요한 데이터를 전달하는 가장 일반적인 방법은 값을 복사해서 전달하는 것이다. 이렇게 하면 호출된 함수가 반환된 이후에도 호출한 함수에 있는 변수의 값은 변하지 않는다. 즉, 호출된 함수의 기능과 상관없이 호출한 함수의 변숫값은 그대로다.

```c
#include <stdio.h>

void add_ten(int a);

int main()
{
    int a = 10;
    add_ten(a);
    printf("a : %d\n", a);
    
    return 0;
}

void add_ten(int a)
{
    a = a + 10;
}
```

변수 a를 인수로 주고 함수를 호출한다. 이 경우 a 값이 복사되어 함수에 전달되며 매개변수 a를 위한 저장공간이 별도로 할당되어 인수로 넘어오는 값을 저장한다.

만약 main 함수의 변수 a가 증가하기를 원한다면 add_ten 함수가 증가시킨 값을 반환하여 main 함수의 a에 다시 대입하는 방법을 사용해야 한다.

```c
int add_ten(int a); // 반환값이 있는 함수로 선언
...
	a = add_ten(a); // 증가한 값을 반환하여 main 함수의 변수 a에 대입
...
int add_ten(int a) // 반환값이 있는 함수로 정의
...
	return a; // 다음 행에 반환 문장 추가
```

호출되는 함수에 값을 복사하여 전달하는 방식은 값을 출력하거나 연산하는 경우와 같이 호출하는 함수의 값을 바꿀 필요가 없는 경우에 사용한다.

---

### 주소를 전달하는 방법

함수를 호출할 때 처리할 변수의 주소를 넘기는 방법도 있다. 이 경우 포인터 연산으로 값을 처리해야 하므로 값을 전달하는 방법보다 불편하다. 하지만 호출된 함수에서 호출한 함수에 있는 변수의 값을 바꿀 수 있다. 즉, 주소를 전달하면 호출한 함수의 변숫값을 바꿀 수 있다.

```c
#include <stdio.h>

void add_ten(int *pa);

int main()
{
    int a = 10;
    add_ten(&a);
    printf("a : %d\n", a);
    
    return 0;
}

void add_ten(int *pa){
    *pa = *pa + 10;
}
```

변수 a의 주소가 함수에 전달되며 포인터를 매개변수로 선언하여 받는다. 따라서 매개변수 pa에 간접 참조 연산자를 사용하면 main 함수에 있는 a를 사용할 수 있으며 그 값을 바꾸는 것도 가능해진다.

---

### 값을 복사해서 전달하는 방식 vs 주소를 전달하는 방식

값을 복사해서 전달하는 방식은 원본 데이터를 보존할 수 있으므로 안정성을 담보 해야 하는 상황에 유용하다. 다만 원본의 데이터 수정이 목적일 경우에는 사용법이 제한적이다.

반대로 주소를 전달하는 방식은 원본 데이터를 바꿀 때 유용하지만 사용법이 복잡하고 절대 바꾸면 안 되는 데이터를 다룰 때 사용하면 문제가 생길 수 있다. 따라서 꼭 피료한 경우가 아니면 값을 복사해서 전달하는 방식을 기본으로 사용한다.

함수를 호출할 때 변수의 값을 복사하여 인수로 주는 방식을 call by value(값에 의한 호출)라고 한다. 반면에 call by reference(참조에 의한 호출)는 호출 함수의 변수를 피호출 함수에서 매개변수의 이름으로 직접 사용하는 방식이다. 따라서 call by reference 방식을 사용하면 하나의 저장 공간을 서로 다른 함수에서 2개의 이름으로 쉽게 공유할 수 있다. 그런데 C 언어에는 call by reference를 구현하는 문법 형식이 없다. 다만 주소를 함수의 인수로 주고 포인터로 받아 간접 참조 연산을 통해 call by reference와 비슷한 효과를 낼 수 있다. 결국 이 방법도 주소 값을 주고받으므로 call by value이다.

---

## 다차원 배열

### 2차원 char 배열

하나의 문자열을 저장하기 위해서는 1차원 char 배열이 필요하고 여러 개의 문자열을 저장하려면 1차원 char 배열이 여러 개 필요하다. 이때 1차원 char 배열을 모아 새로운 배열을 만드는 것이 효율적이다.

2차원의 char 배열은 이렇게 여러 개의 문자열을 처리할 때 사용한다. 즉, 여러개의 문자열은 2차원 char 배열로 처리한다.

```c
#include <stdio.h>

int main(void)
{
    char animal[5][20];
    int i;
    int count;
    
    count = sizeof(animal) / sizeof(animal[0]);
    
    for (i = 0; i < count; i++)
    {
        scanf("%s", animal[i]);
    }
    for(i=0;i<count;i++)
    {
        printf("%s ", animal[i]);
    }
    return 0;
}
```

5개의 동물 이름을 저장하려면 2차원 char 배열이 필요하다. 5개의 문자열을 저장해야 하므로 행의 수는 5행이며 열의 수는 가장 긴 동물 이름도 저장할 수 있도록 넉넉하게 선언한다. animal 배열을 선언하면 100개의 char형 저장 공간이 생긴다.

각 행은 하나의 1차원 char 배열이며 부분배열명이 각 행의 배열명의 기능을 한다. 따라서 부분배열명을 사용하여 각 행에 하나의 문자열을 입력할 수 있다.

animal[0]은 배열명으로 부분배열의 시작 위치 값이다. 따라서 앞에 주소 연산자 &를 붙일 필요가 없다. 배열명의 표현식이 특이해 자칫 하나의 변수로 오해할 수 있으나 2차원 배열에서는 부분배열의 이름이 된다.

행의 수를 계산식으로 구하는 문장

count = sizeof(animal) / sizeof(animal[0]);     ⇒      배열 전체의 크기 / 부분배열 하나의 크기

---
